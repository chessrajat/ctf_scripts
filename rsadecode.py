# n = 3349683240683303752040100187123245076775802838668125325785318315004398778586538866210198083573169673444543518654385038484177110828274648967185831623610409867689938609495858551308025785883804091
# e = 65537
# ct = 87760575554266991015431110922576261532159376718765701749513766666239189012106797683148334771446801021047078003121816710825033894805743112580942399985961509685534309879621205633997976721084983

n = 14783703403657671882600600446061886156235531325852194800287001788765221084107631153330658325830443132164971084137462046607458019775851952933254941568056899
e = 65537
c = 1024748651240589384080193904546301206891719290374713006728370641557757899466814045865587252185625020802650532816622991384627458755869483218276850927376246

# Here we will use "n"  to get factors and the values of p and Q

# http://factordb.com/
#http://factordb.com/index.php?query=58900433780152059829684181006276669633073820320761216330291745734792546625247

p = 121588253559534573498320028934517990374721243335397811413129137253981502291629
q = 121588253559534573498320028934517990374721243335397811413129137253981502291631



def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m


totient = (p - 1) * (q - 1)
d = modinv(e,totient)
m = pow(c, d, n)

flag = (hex(m)[2:])
print('unhex it: '+ flag)
print(bytes.fromhex(flag).decode())